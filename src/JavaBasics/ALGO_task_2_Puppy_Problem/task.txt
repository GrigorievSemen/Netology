Задача о щенке
У вас есть квадратное поле клеток n на n. В каждой клетке может находиться кактус. В левом верхнем углу находится щенок. Щенок может перемещаться только на клетку вправо или на клетку вниз, причём он не может премещаться в клетку, в которой находится кактус.
Вам надо написать функцию, которая принимала бы параметрами поле в виде двумерного массива, две координаты клетки, в которой находится хозяин щенка, и которая выводила бы на экран поле с маршрутом для щенка из левого верхнего угла до человека. Если такого маршрута нет, программа должна сообщить об этом.
Координаты считаются так: слева сверху x = 0, y = 0, координата x растёт вправо, координата y растёт вниз, т.е. левый нижний угол имеет координаты (0; n-1), правый нижний (n-1; n-1), правый верхний (n-1; 0).
Например, поле может выглядеть так (Щ - щенок, Ч - человек, * - кактус):
Щ - - * * - - - - -
- - - - * - * * - -
- - - * - * - - - *
- * - - - - - - Ч -
- - - - - - * - - -
- - * - - * - - - -
- - - * - - * * * -
- - - - - - - * - -
- - - - - - - * - -
- - - - - * * - - -
Результат работы программы (x - маршрут щенка):
Щ - - * * - - - - -
x - - - * - * * - -
x x x * - * - - - *
- * x x x x x x Ч -
- - - - - - * - - -
- - * - - * - - - -
- - - * - - * * * -
- - - - - - - * - -
- - - - - - - * - -
- - - - - * * - - -
Программа должна работать за время и дополнительную память не хуже чем O(n2). Подумайте, как бы вы решили задачу, используя принцип динамического программирования?
Решение
Давайте решим вспомогательную задачу и напишем функцию, которая вместо прорисовки готового поля будет просто возвращать для полученных в параметрах координат направление, откуда в эту клетку прибежит щенок если такой путь существует: U если щенок в эту клетку прибежит сверху, L если слева, N если щенок не может добраться в эту клетку. Если может прибежать с обоих направлений, то выбираем любое из них.
Пусть мы уже написали такую функцию и назвали её where_from(field, x, y). Теперь решим нашу исходную задачу через эту вспомогательную: просто вызовем от запрашиваемых координат вспомогательную задачу, она даст нам направление, откуда прибежит щенок. Перейдём по этому направлению и вызовем вспомогательную задачу уже от новых координат. Будем так делать до тех пор, пока не дойдём до клетки с координатами (0; 0), т.е. до изначальной клетки для щенка:
public static void find_path(String[][] field, int x0, int y0) {
    String[][] path = new String[size][size];
    String[][] memory = new String[size][size];
    int x = x0;
    int y = y0;

    label:
    while (x != 0 || y != 0) {
        String direction = where_from(field, x, y, memory);

        switch (direction) {
            case "N":
                System.out.println("Нет такого пути :(");
                break label;
            case "U":
                path[x][y] = "да";
                y -= 1;
                break;
            case "L":
                path[x][y] = "да";
                x -= 1;
                break;
        }
    }

    for (y = 0; y < size; y++) {
        for (x = 0; x < size; x++) {
            if (x == x0 && y == y0) {
                field[x][y] = "Ч";
            } else if (path[x][y] != null) {
                field[x][y] = "x";
            }
        }
    }
    Arrays.stream(field).map(Arrays::toString).forEach(System.out::println);
}

Как же теперь быстро и эффективно решить вспомогательную задачу, т.е. написать функцию where_from? Давайте решим её динамикой! А именно, решение для заданных координат будем выражать через рекурсивное решение для других координат, а все ответы будем запоминать в двумерном массиве чтобы не пересчитывать.
Как же нам написать рекурсивное решение? Давайте подумаем, если мы находимся в клетке с координатами (x; y), то в качестве ответа от нас ждут U если щенок может прибежать в неё сверху, L если слева, N если не может сюда прибежать (если может с обоих направлений, то указать любое из них). Рекурсия будет выглядить следующим образом: если слева у нас доступная клетка, не кактус, то вызовем рекурсивно where_from от неё и, если этот вызов вернул не N (т.е. в эту клетку может попасть щенок), то и мы вернём в качестве ответа L (т.е. иди из текущей в левую). Если же нам вернули N, то провернём тоже самое с верхней клеткой. Если же и у неё N (или там были кактусы, или клеток не было тк мы были на границе поля), то вернём N.
Не забудем запоминать для каждой вызванной координаты ответ в двумерном массиве, который будем передавать дополнительным параметром. Рекурсия гарантировано закончится, тк на каждом вызове мы двигаемся либо влево, либо вверх, а такое делать бесконечно невозможно. Запоминание результатов в массиве гарантирует нам, что для каждой клетки максимум только один раз произойдут рекурсивные вызовы. В результате, мы получим суммарную асимптотику O(n2), тк количество ячеек n2.
